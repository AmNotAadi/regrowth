<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="apple-touch-icon" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Regrowth - Premium Web Design Agency</title>
    <meta name="description" content="Transform your business with professional web design. Affordable packages starting at ‚Çπ999." />
    
    <style>
      /* Mobile - disable system dark mode filters only */
      @media (max-width: 768px) {
        html, body {
          filter: none !important;
          -webkit-filter: none !important;
        }
      }
    </style>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Space+Grotesk:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script type="module" crossorigin src="/assets/index-ClTXjFut.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-Gkp1scXd.css">

    <style>
      /* Mobile dark theme overrides to keep design consistent */
      @media (max-width: 768px) {
        :root,
        html,
        body {
          color-scheme: dark !important;
          background-color: #050505 !important;
        }

        body,
        .mobile-app,
        .mobile-hero,
        .mobile-services,
        .mobile-portfolio,
        .mobile-pricing,
        .mobile-pricing-immersive,
        .pricing-section,
        .mobile-revamp,
        .mobile-contact,
        .mobile-footer {
          background-color: #050505 !important;
          color: #ffffff !important;
        }

        .mobile-hero-title,
        .mobile-section-title,
        .portfolio-immersive-title,
        .portfolio-immersive-description,
        .revamp-tile *,
        .contact-tile *,
        .pricing-title,
        .pricing-title-immersive,
        .pricing-price .currency,
        .pricing-price .amount,
        .pricing-price-immersive .amount-large,
        .contact-content h3,
        .contact-content p,
        .mobile-contact-card,
        .mobile-contact-card p,
        .mobile-pricing-card,
        .mobile-pricing-card .pricing-price .amount,
        .mobile-pricing-card .pricing-price .currency,
        .mobile-pricing-card-premium .currency-premium,
        .mobile-pricing-card-premium .amount-premium {
          color: #ffffff !important;
          -webkit-text-fill-color: #ffffff !important;
        }

        .mobile-pricing-card,
        .mobile-pricing-card-premium,
        .pricing-card-immersive,
        .mobile-contact-card,
        .contact-tile,
        .revamp-tile,
        .pricing-tile {
          background: rgba(12, 12, 18, 0.92) !important;
          border-color: rgba(255, 255, 255, 0.1) !important;
        }
      }
    </style>
    
    <!-- Dynamic Pricing Script -->
    <script>
      // Pricing configuration
      const PRICING = {
        IN: { currency: '‚Çπ', symbol: '‚Çπ', prices: [999, 1499, 1999, 2999] },
        US: { currency: 'USD', symbol: '$', prices: [79, 109, 139, 199] }
      };
      
      // Debug mode - set to true to see console logs
      const DEBUG = true;
      
      function log(...args) {
        if (DEBUG) console.log('[Pricing]', ...args);
      }
      
      // Try multiple geolocation services with fallbacks
      async function detectLocation() {
        const services = [
          // Service 1: ipapi.co (reliable, good for VPN detection)
          async () => {
            const res = await fetch('https://ipapi.co/json/');
            const data = await res.json();
            return { country: data.country_code, currency: data.currency, service: 'ipapi.co' };
          },
          // Service 2: ipwhois.app (alternative)
          async () => {
            const res = await fetch('https://ipwhois.app/json/');
            const data = await res.json();
            return { country: data.country_code, currency: data.currency, service: 'ipwhois.app' };
          },
          // Service 3: ip-api.com (free, no signup needed)
          async () => {
            const res = await fetch('https://ip-api.com/json/');
            const data = await res.json();
            return { country: data.countryCode, currency: data.currency, service: 'ip-api.com' };
          }
        ];
        
        for (let i = 0; i < services.length; i++) {
          try {
            const result = await services[i]();
            log('Location detected:', result);
            return result;
          } catch (error) {
            log(`Service ${i + 1} failed:`, error.message);
            if (i === services.length - 1) throw error;
          }
        }
      }
      
      // Fetch user's country and set pricing
      async function setPricing() {
        try {
          const location = await detectLocation();
          const countryCode = location.country;
          
          log('Country Code:', countryCode);
          
          let pricing;
          if (countryCode === 'IN') {
            pricing = PRICING.IN;
            log('Using Indian pricing');
          } else {
            // For all other countries, convert from USD
            const currencyCode = location.currency || 'USD';
            log('Currency Code:', currencyCode);
            
            const exchangeRate = await getExchangeRate(currencyCode);
            log('Exchange Rate (USD to ' + currencyCode + '):', exchangeRate);
            
            pricing = {
              currency: currencyCode,
              symbol: getCurrencySymbol(currencyCode),
              prices: PRICING.US.prices.map(usdPrice => Math.round(usdPrice * exchangeRate))
            };
            log('Converted prices:', pricing.prices);
          }
          
          // Store pricing data globally
          window.REGROWTH_PRICING = pricing;
          log('Pricing set:', pricing);
          
          // Add visual indicator for debugging
          if (DEBUG) {
            setTimeout(() => {
              const indicator = document.createElement('div');
              indicator.style.cssText = 'position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.8);color:#fff;padding:8px 12px;border-radius:6px;font-size:12px;z-index:999999;font-family:monospace;';
              indicator.innerHTML = `üìç ${countryCode}<br>${pricing.symbol}${pricing.prices[0]}`;
              document.body.appendChild(indicator);
              setTimeout(() => indicator.remove(), 5000);
            }, 500);
          }
          
          // Update pricing in DOM after delays to ensure React has rendered
          setTimeout(() => updatePricingInDOM(pricing), 2000);
          setTimeout(() => updatePricingInDOM(pricing), 3000);
          setTimeout(() => updatePricingInDOM(pricing), 4000);
          setTimeout(() => updatePricingInDOM(pricing), 5000);
        } catch (error) {
          log('ERROR: Failed to fetch location, using Indian pricing:', error);
          window.REGROWTH_PRICING = PRICING.IN;
          setTimeout(() => updatePricingInDOM(PRICING.IN), 1000);
        }
      }
      
      function updatePricingInDOM(pricing) {
        log('Updating prices in DOM with:', pricing);

        const BASE_PRICE_INDEX = {
          999: 0,
          1499: 1,
          1999: 2,
          2999: 3,
          79: 0,
          109: 1,
          139: 2,
          199: 3
        };

        const formatPrice = (value) => pricing.prices[value].toLocaleString();

        // Update currency spans with the detected symbol
        const currencySelectors = [
          '.currency',
          '.currency-premium',
          '.pricing-price .currency',
          '.pricing-price-immersive .currency',
          '.pricing-price-premium .currency-premium'
        ].join(', ');

        document.querySelectorAll(currencySelectors).forEach(node => {
          if (node && node.textContent !== pricing.symbol) {
            node.textContent = pricing.symbol;
          }
        });

        // Update amount spans (desktop + mobile + immersive)
        const amountSelectors = [
          '.amount',
          '.amount-premium',
          '.amount-large',
          '.pricing-price .amount',
          '.pricing-price .amount-premium',
          '.pricing-price-immersive .amount-large',
          '.pricing-price-premium .amount-premium'
        ].join(', ');

        let structuredUpdates = 0;

        document.querySelectorAll(amountSelectors).forEach(node => {
          if (!node) return;

          const storedBase = node.dataset.basePrice;
          let baseValue = storedBase ? parseInt(storedBase, 10) : parseInt((node.textContent || '').replace(/[^0-9]/g, ''), 10);

          if (!storedBase && !Number.isNaN(baseValue)) {
            node.dataset.basePrice = baseValue;
          }

          if (Number.isNaN(baseValue)) return;
          const priceIndex = BASE_PRICE_INDEX[baseValue];
          if (priceIndex === undefined) return;

          const formatted = formatPrice(priceIndex);
          if (node.textContent !== formatted) {
            node.textContent = formatted;
            structuredUpdates++;
          }
        });

        // Fallback replacements for any stray text nodes (e.g., hero badges)
        const priceReplacements = [
          { from: ['‚Çπ999', '‚Çπ 999', '$79', '$ 79'], to: pricing.symbol + pricing.prices[0].toLocaleString() },
          { from: ['‚Çπ1,499', '‚Çπ1499', '‚Çπ 1,499', '$109', '$ 109'], to: pricing.symbol + pricing.prices[1].toLocaleString() },
          { from: ['‚Çπ1,999', '‚Çπ1999', '‚Çπ 1,999', '$139', '$ 139'], to: pricing.symbol + pricing.prices[2].toLocaleString() },
          { from: ['‚Çπ2,999', '‚Çπ2999', '‚Çπ 2,999', '$199', '$ 199'], to: pricing.symbol + pricing.prices[3].toLocaleString() }
        ];

        const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
        let fallbackUpdates = 0;

        while (walker.nextNode()) {
          const node = walker.currentNode;
          if (!node || !node.nodeValue) continue;
          if (!node.nodeValue.includes('‚Çπ') && !node.nodeValue.includes('$')) continue;

          let updatedValue = node.nodeValue;
          priceReplacements.forEach(replacement => {
            replacement.from.forEach(oldPrice => {
              if (updatedValue.includes(oldPrice)) {
                updatedValue = updatedValue.replace(new RegExp(oldPrice.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), replacement.to);
              }
            });
          });

          if (updatedValue !== node.nodeValue) {
            node.nodeValue = updatedValue;
            fallbackUpdates++;
          }
        }

        log('Updated', structuredUpdates, 'structured price nodes and', fallbackUpdates, 'fallback text nodes');
      }
      
      async function getExchangeRate(targetCurrency) {
        try {
          const response = await fetch(`https://api.exchangerate-api.com/v4/latest/USD`);
          const data = await response.json();
          return data.rates[targetCurrency] || 1;
        } catch (error) {
          console.warn('Exchange rate fetch failed, using 1:1');
          return 1;
        }
      }
      
      function getCurrencySymbol(currencyCode) {
        const symbols = {
          USD: '$', EUR: '‚Ç¨', GBP: '¬£', JPY: '¬•', CNY: '¬•',
          AUD: 'A$', CAD: 'C$', CHF: 'CHF', SEK: 'kr', NZD: 'NZ$',
          SGD: 'S$', HKD: 'HK$', NOK: 'kr', KRW: '‚Ç©', TRY: '‚Ç∫',
          RUB: '‚ÇΩ', BRL: 'R$', ZAR: 'R', MXN: '$', AED: 'ÿØ.ÿ•',
          SAR: 'Ô∑º', PLN: 'z≈Ç', THB: '‡∏ø', IDR: 'Rp', MYR: 'RM',
          PHP: '‚Ç±', DKK: 'kr', CZK: 'Kƒç', HUF: 'Ft', ILS: '‚Ç™',
          CLP: '$', ARS: '$', COP: '$', PEN: 'S/', VND: '‚Ç´',
          EGP: '¬£', PKR: '‚Ç®', BDT: '‡ß≥', LKR: 'Rs', KES: 'KSh',
          NGN: '‚Ç¶', UAH: '‚Ç¥', RON: 'lei', BGN: '–ª–≤'
        };
        return symbols[currencyCode] || currencyCode + ' ';
      }
      
      // Run on page load
      setPricing();
      
      // Also update pricing whenever DOM changes (for React re-renders)
      if (window.MutationObserver) {
        const observer = new MutationObserver(() => {
          if (window.REGROWTH_PRICING) {
            updatePricingInDOM(window.REGROWTH_PRICING);
          }
        });
        
        // Start observing after a delay
        setTimeout(() => {
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
        }, 2000);
      }
    </script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
