<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="apple-touch-icon" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Regrowth - Premium Web Design Agency</title>
    <meta name="description" content="Transform your business with professional web design. Affordable packages starting at ‚Çπ999." />
    
    <style>
      /* Force disable dark mode filters - MOBILE ONLY */
      @media (max-width: 768px) {
        :root {
          color-scheme: light only !important;
        }
        
        html, body {
          color-scheme: light only !important;
          background-color: #ffffff !important;
          filter: none !important;
        }
        
        /* Force full opacity on all text elements */
        * {
          color-scheme: light only !important;
          -webkit-text-fill-color: initial !important;
        }
        
        /* Disable any dark mode media queries on mobile */
        @media (prefers-color-scheme: dark) {
          :root, html, body, * {
            color-scheme: light only !important;
            background-color: inherit !important;
            color: inherit !important;
            filter: none !important;
          }
        }
      }
    </style>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Space+Grotesk:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script type="module" crossorigin src="/assets/index-ClTXjFut.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-Gkp1scXd.css">
    
    <!-- Dynamic Pricing Script -->
    <script>
      // Pricing configuration
      const PRICING = {
        IN: { currency: '‚Çπ', symbol: '‚Çπ', prices: [999, 1499, 1999, 2999] },
        US: { currency: 'USD', symbol: '$', prices: [79, 109, 139, 199] }
      };
      
      // Debug mode - set to true to see console logs
      const DEBUG = true;
      
      function log(...args) {
        if (DEBUG) console.log('[Pricing]', ...args);
      }
      
      // Try multiple geolocation services with fallbacks
      async function detectLocation() {
        const services = [
          // Service 1: ipapi.co (reliable, good for VPN detection)
          async () => {
            const res = await fetch('https://ipapi.co/json/');
            const data = await res.json();
            return { country: data.country_code, currency: data.currency, service: 'ipapi.co' };
          },
          // Service 2: ipwhois.app (alternative)
          async () => {
            const res = await fetch('https://ipwhois.app/json/');
            const data = await res.json();
            return { country: data.country_code, currency: data.currency, service: 'ipwhois.app' };
          },
          // Service 3: ip-api.com (free, no signup needed)
          async () => {
            const res = await fetch('https://ip-api.com/json/');
            const data = await res.json();
            return { country: data.countryCode, currency: data.currency, service: 'ip-api.com' };
          }
        ];
        
        for (let i = 0; i < services.length; i++) {
          try {
            const result = await services[i]();
            log('Location detected:', result);
            return result;
          } catch (error) {
            log(`Service ${i + 1} failed:`, error.message);
            if (i === services.length - 1) throw error;
          }
        }
      }
      
      // Fetch user's country and set pricing
      async function setPricing() {
        try {
          const location = await detectLocation();
          const countryCode = location.country;
          
          log('Country Code:', countryCode);
          
          let pricing;
          if (countryCode === 'IN') {
            pricing = PRICING.IN;
            log('Using Indian pricing');
          } else {
            // For all other countries, convert from USD
            const currencyCode = location.currency || 'USD';
            log('Currency Code:', currencyCode);
            
            const exchangeRate = await getExchangeRate(currencyCode);
            log('Exchange Rate (USD to ' + currencyCode + '):', exchangeRate);
            
            pricing = {
              currency: currencyCode,
              symbol: getCurrencySymbol(currencyCode),
              prices: PRICING.US.prices.map(usdPrice => Math.round(usdPrice * exchangeRate))
            };
            log('Converted prices:', pricing.prices);
          }
          
          // Store pricing data globally
          window.REGROWTH_PRICING = pricing;
          log('Pricing set:', pricing);
          
          // Add visual indicator for debugging
          if (DEBUG) {
            setTimeout(() => {
              const indicator = document.createElement('div');
              indicator.style.cssText = 'position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.8);color:#fff;padding:8px 12px;border-radius:6px;font-size:12px;z-index:999999;font-family:monospace;';
              indicator.innerHTML = `üìç ${countryCode}<br>${pricing.symbol}${pricing.prices[0]}`;
              document.body.appendChild(indicator);
              setTimeout(() => indicator.remove(), 5000);
            }, 500);
          }
          
          // Update pricing in DOM after delays to ensure React has rendered
          setTimeout(() => updatePricingInDOM(pricing), 2000);
          setTimeout(() => updatePricingInDOM(pricing), 3000);
          setTimeout(() => updatePricingInDOM(pricing), 4000);
          setTimeout(() => updatePricingInDOM(pricing), 5000);
        } catch (error) {
          log('ERROR: Failed to fetch location, using Indian pricing:', error);
          window.REGROWTH_PRICING = PRICING.IN;
          setTimeout(() => updatePricingInDOM(PRICING.IN), 1000);
        }
      }
      
      function updatePricingInDOM(pricing) {
        log('Updating prices in DOM with:', pricing);
        
        // Update all text nodes
        const walker = document.createTreeWalker(
          document.body,
          NodeFilter.SHOW_TEXT,
          null,
          false
        );
        
        const nodesToUpdate = [];
        let updateCount = 0;
        
        while (walker.nextNode()) {
          const node = walker.currentNode;
          if (node.nodeValue && (node.nodeValue.includes('‚Çπ') || node.nodeValue.includes('$'))) {
            nodesToUpdate.push(node);
            if (DEBUG) log('Found text node with price:', node.nodeValue.trim());
          }
        }
        
        log('Found', nodesToUpdate.length, 'text nodes with currency symbols');
        
        // Define all possible price patterns to match
        const priceMap = {
          '999': pricing.symbol + pricing.prices[0].toLocaleString(),
          '1499': pricing.symbol + pricing.prices[1].toLocaleString(),
          '1,499': pricing.symbol + pricing.prices[1].toLocaleString(),
          '1999': pricing.symbol + pricing.prices[2].toLocaleString(),
          '1,999': pricing.symbol + pricing.prices[2].toLocaleString(),
          '2999': pricing.symbol + pricing.prices[3].toLocaleString(),
          '2,999': pricing.symbol + pricing.prices[3].toLocaleString(),
          '79': pricing.symbol + pricing.prices[0].toLocaleString(),
          '109': pricing.symbol + pricing.prices[1].toLocaleString(),
          '139': pricing.symbol + pricing.prices[2].toLocaleString(),
          '199': pricing.symbol + pricing.prices[3].toLocaleString()
        };
        
        nodesToUpdate.forEach(node => {
          let text = node.nodeValue;
          let originalText = text;
          
          // Try to match and replace any currency + number pattern
          Object.keys(priceMap).forEach(price => {
            // Match ‚Çπ999, ‚Çπ 999, $79, $ 79, etc.
            const patterns = [
              new RegExp('‚Çπ\\s*' + price, 'g'),
              new RegExp('\\$\\s*' + price, 'g')
            ];
            
            patterns.forEach(pattern => {
              if (pattern.test(text)) {
                text = text.replace(pattern, priceMap[price]);
                if (DEBUG) log('Replaced:', originalText.trim(), '‚Üí', text.trim());
              }
            });
          });
          
          if (text !== originalText) {
            node.nodeValue = text;
            updateCount++;
          }
        });
        
        log('Updated', updateCount, 'price elements');
      }
      
      async function getExchangeRate(targetCurrency) {
        try {
          const response = await fetch(`https://api.exchangerate-api.com/v4/latest/USD`);
          const data = await response.json();
          return data.rates[targetCurrency] || 1;
        } catch (error) {
          console.warn('Exchange rate fetch failed, using 1:1');
          return 1;
        }
      }
      
      function getCurrencySymbol(currencyCode) {
        const symbols = {
          USD: '$', EUR: '‚Ç¨', GBP: '¬£', JPY: '¬•', CNY: '¬•',
          AUD: 'A$', CAD: 'C$', CHF: 'CHF', SEK: 'kr', NZD: 'NZ$',
          SGD: 'S$', HKD: 'HK$', NOK: 'kr', KRW: '‚Ç©', TRY: '‚Ç∫',
          RUB: '‚ÇΩ', BRL: 'R$', ZAR: 'R', MXN: '$', AED: 'ÿØ.ÿ•',
          SAR: 'Ô∑º', PLN: 'z≈Ç', THB: '‡∏ø', IDR: 'Rp', MYR: 'RM',
          PHP: '‚Ç±', DKK: 'kr', CZK: 'Kƒç', HUF: 'Ft', ILS: '‚Ç™',
          CLP: '$', ARS: '$', COP: '$', PEN: 'S/', VND: '‚Ç´',
          EGP: '¬£', PKR: '‚Ç®', BDT: '‡ß≥', LKR: 'Rs', KES: 'KSh',
          NGN: '‚Ç¶', UAH: '‚Ç¥', RON: 'lei', BGN: '–ª–≤'
        };
        return symbols[currencyCode] || currencyCode + ' ';
      }
      
      // Run on page load
      setPricing();
      
      // Also update pricing whenever DOM changes (for React re-renders)
      if (window.MutationObserver) {
        const observer = new MutationObserver(() => {
          if (window.REGROWTH_PRICING) {
            updatePricingInDOM(window.REGROWTH_PRICING);
          }
        });
        
        // Start observing after a delay
        setTimeout(() => {
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
        }, 2000);
      }
    </script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
