<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="apple-touch-icon" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Regrowth - Premium Web Design Agency</title>
    <meta name="description" content="Transform your business with professional web design. Affordable packages starting at ‚Çπ999." />
    
    <style>
      /* Mobile styling - consistent dark theme regardless of device setting */
      @media (max-width: 768px) {
        :root {
          color-scheme: dark !important;
        }
        
        html, body {
          background-color: #000000 !important;
          color: #ffffff !important;
          filter: none !important;
        }
        
        /* Force dark background and light text on all elements */
        * {
          color-scheme: dark !important;
        }
        
        /* Override any light backgrounds */
        section, div, header, nav, main, footer {
          background-color: #000000 !important;
        }
        
        /* Make all text white/light colored */
        h1, h2, h3, h4, h5, h6, p, span, a, li, label {
          color: #ffffff !important;
          -webkit-text-fill-color: #ffffff !important;
        }
        
        /* Purple glowy accents */
        button, .btn, a[href*="mailto"], a[href*="tel"] {
          background: linear-gradient(135deg, #8b5cf6, #a78bfa) !important;
          color: #ffffff !important;
          box-shadow: 0 0 20px rgba(139, 92, 246, 0.5) !important;
        }
        
        /* Ensure cards/sections maintain dark theme */
        [class*="card"], [class*="section"], [class*="container"] {
          background-color: #000000 !important;
        }
      }
    </style>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Space+Grotesk:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script type="module" crossorigin src="/assets/index-ClTXjFut.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-Gkp1scXd.css">
    
    <!-- Dynamic Pricing Script -->
    <script>
      // Pricing configuration
      const PRICING = {
        IN: { currency: '‚Çπ', symbol: '‚Çπ', prices: [999, 1499, 1999, 2999] },
        US: { currency: 'USD', symbol: '$', prices: [79, 109, 139, 199] }
      };
      
      // Debug mode - set to true to see console logs
      const DEBUG = true;
      
      function log(...args) {
        if (DEBUG) console.log('[Pricing]', ...args);
      }
      
      // Try multiple geolocation services with fallbacks
      async function detectLocation() {
        const services = [
          // Service 1: ipapi.co (reliable, good for VPN detection)
          async () => {
            const res = await fetch('https://ipapi.co/json/');
            const data = await res.json();
            return { country: data.country_code, currency: data.currency, service: 'ipapi.co' };
          },
          // Service 2: ipwhois.app (alternative)
          async () => {
            const res = await fetch('https://ipwhois.app/json/');
            const data = await res.json();
            return { country: data.country_code, currency: data.currency, service: 'ipwhois.app' };
          },
          // Service 3: ip-api.com (free, no signup needed)
          async () => {
            const res = await fetch('https://ip-api.com/json/');
            const data = await res.json();
            return { country: data.countryCode, currency: data.currency, service: 'ip-api.com' };
          }
        ];
        
        for (let i = 0; i < services.length; i++) {
          try {
            const result = await services[i]();
            log('Location detected:', result);
            return result;
          } catch (error) {
            log(`Service ${i + 1} failed:`, error.message);
            if (i === services.length - 1) throw error;
          }
        }
      }
      
      // Fetch user's country and set pricing
      async function setPricing() {
        try {
          const location = await detectLocation();
          const countryCode = location.country;
          
          log('Country Code:', countryCode);
          
          let pricing;
          if (countryCode === 'IN') {
            pricing = PRICING.IN;
            log('Using Indian pricing');
          } else {
            // For all other countries, convert from USD
            const currencyCode = location.currency || 'USD';
            log('Currency Code:', currencyCode);
            
            const exchangeRate = await getExchangeRate(currencyCode);
            log('Exchange Rate (USD to ' + currencyCode + '):', exchangeRate);
            
            pricing = {
              currency: currencyCode,
              symbol: getCurrencySymbol(currencyCode),
              prices: PRICING.US.prices.map(usdPrice => Math.round(usdPrice * exchangeRate))
            };
            log('Converted prices:', pricing.prices);
          }
          
          // Store pricing data globally
          window.REGROWTH_PRICING = pricing;
          log('Pricing set:', pricing);
          
          // Add visual indicator for debugging
          if (DEBUG) {
            setTimeout(() => {
              const indicator = document.createElement('div');
              indicator.style.cssText = 'position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.8);color:#fff;padding:8px 12px;border-radius:6px;font-size:12px;z-index:999999;font-family:monospace;';
              indicator.innerHTML = `üìç ${countryCode}<br>${pricing.symbol}${pricing.prices[0]}`;
              document.body.appendChild(indicator);
              setTimeout(() => indicator.remove(), 5000);
            }, 500);
          }
          
          // Update pricing in DOM after delays to ensure React has rendered
          setTimeout(() => updatePricingInDOM(pricing), 2000);
          setTimeout(() => updatePricingInDOM(pricing), 3000);
          setTimeout(() => updatePricingInDOM(pricing), 4000);
          setTimeout(() => updatePricingInDOM(pricing), 5000);
        } catch (error) {
          log('ERROR: Failed to fetch location, using Indian pricing:', error);
          window.REGROWTH_PRICING = PRICING.IN;
          setTimeout(() => updatePricingInDOM(PRICING.IN), 1000);
        }
      }
      
      function updatePricingInDOM(pricing) {
        log('Updating prices in DOM with:', pricing);
        
        // Find all elements containing price text by looking at innerHTML
        const allElements = document.querySelectorAll('*');
        let updateCount = 0;
        
        const priceReplacements = [
          { from: ['‚Çπ999', '‚Çπ 999', '$79', '$ 79'], to: pricing.symbol + pricing.prices[0].toLocaleString() },
          { from: ['‚Çπ1,499', '‚Çπ1499', '‚Çπ 1,499', '$109', '$ 109'], to: pricing.symbol + pricing.prices[1].toLocaleString() },
          { from: ['‚Çπ1,999', '‚Çπ1999', '‚Çπ 1,999', '$139', '$ 139'], to: pricing.symbol + pricing.prices[2].toLocaleString() },
          { from: ['‚Çπ2,999', '‚Çπ2999', '‚Çπ 2,999', '$199', '$ 199'], to: pricing.symbol + pricing.prices[3].toLocaleString() }
        ];
        
        allElements.forEach(element => {
          // Skip if element has no text or is a script/style tag
          if (!element.textContent || element.tagName === 'SCRIPT' || element.tagName === 'STYLE') return;
          
          // Only process leaf elements (elements with no child elements, only text)
          if (element.children.length === 0 && (element.textContent.includes('‚Çπ') || element.textContent.includes('$'))) {
            let originalText = element.textContent;
            let newText = originalText;
            
            priceReplacements.forEach(replacement => {
              replacement.from.forEach(oldPrice => {
                if (newText.includes(oldPrice)) {
                  newText = newText.replace(new RegExp(oldPrice.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), replacement.to);
                  if (DEBUG) log('Replacing in element:', oldPrice, '‚Üí', replacement.to);
                }
              });
            });
            
            if (newText !== originalText) {
              element.textContent = newText;
              updateCount++;
            }
          }
        });
        
        log('Updated', updateCount, 'price elements');
      }
      
      async function getExchangeRate(targetCurrency) {
        try {
          const response = await fetch(`https://api.exchangerate-api.com/v4/latest/USD`);
          const data = await response.json();
          return data.rates[targetCurrency] || 1;
        } catch (error) {
          console.warn('Exchange rate fetch failed, using 1:1');
          return 1;
        }
      }
      
      function getCurrencySymbol(currencyCode) {
        const symbols = {
          USD: '$', EUR: '‚Ç¨', GBP: '¬£', JPY: '¬•', CNY: '¬•',
          AUD: 'A$', CAD: 'C$', CHF: 'CHF', SEK: 'kr', NZD: 'NZ$',
          SGD: 'S$', HKD: 'HK$', NOK: 'kr', KRW: '‚Ç©', TRY: '‚Ç∫',
          RUB: '‚ÇΩ', BRL: 'R$', ZAR: 'R', MXN: '$', AED: 'ÿØ.ÿ•',
          SAR: 'Ô∑º', PLN: 'z≈Ç', THB: '‡∏ø', IDR: 'Rp', MYR: 'RM',
          PHP: '‚Ç±', DKK: 'kr', CZK: 'Kƒç', HUF: 'Ft', ILS: '‚Ç™',
          CLP: '$', ARS: '$', COP: '$', PEN: 'S/', VND: '‚Ç´',
          EGP: '¬£', PKR: '‚Ç®', BDT: '‡ß≥', LKR: 'Rs', KES: 'KSh',
          NGN: '‚Ç¶', UAH: '‚Ç¥', RON: 'lei', BGN: '–ª–≤'
        };
        return symbols[currencyCode] || currencyCode + ' ';
      }
      
      // Run on page load
      setPricing();
      
      // Also update pricing whenever DOM changes (for React re-renders)
      if (window.MutationObserver) {
        const observer = new MutationObserver(() => {
          if (window.REGROWTH_PRICING) {
            updatePricingInDOM(window.REGROWTH_PRICING);
          }
        });
        
        // Start observing after a delay
        setTimeout(() => {
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
        }, 2000);
      }
    </script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
